const initSocket = (onMessage) => {
    const socket = new WebSocket("ws://localhost:8080/ws");
  
    socket.onopen = () => {
      console.log("WebSocket –ø–æ–¥–∫–ª—é—á—ë–Ω");
    };
  
    socket.onmessage = (event) => {
      const data = JSON.parse(event.data);
      onMessage(data);
    };
  
    socket.onclose = () => {
      console.log("WebSocket –æ—Ç–∫–ª—é—á—ë–Ω");
    };
  
    return socket;
  };
  
  export default initSocket;
  
// src/App.js
import React, { useEffect, useState } from 'react';
import Lobby from './Lobby';
import GameBoard from './GameBoard';
import ScoreBoard from './ScoreBoard';
import Timer from './Timer';
import initSocket from './api';

const App = () => {
  const [socket, setSocket] = useState(null);
  const [myId, setMyId] = useState(null);
  const [inLobby, setInLobby] = useState(true);
  const [lobbyPlayers, setLobbyPlayers] = useState({});
  const [gameState, setGameState] = useState(null);


  useEffect(() => {
    const ws = initSocket();
    setSocket(ws);
    ws.onmessage = (evt) => {
      const msg = JSON.parse(evt.data);
      switch (msg.type) {
        // –ü—Ä–∏—Å–≤–æ–∏–ª–∏ —Å–≤–æ–π ID
        case 'lobby/joined':
          setMyId(msg.id);
          break;

        // –û–±–Ω–æ–≤–∏–ª–∏ —Å–æ—Å—Ç–∞–≤ –ª–æ–±–±–∏
        case 'lobby/update':
          setLobbyPlayers(msg.players);
          break;

        // –í—Å–µ –≥–æ—Ç–æ–≤—ã ‚Äî —Å—Ç–∞—Ä—Ç –∏–≥—Ä—ã
        case 'game/start':
          setInLobby(false);
          break;

        // –ò–≥—Ä–æ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        case 'state':
          setGameState(msg.state);
          break;

        case 'lobby/reset':
          // –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω—ã–π –≤–æ–∑–≤—Ä–∞—Ç –≤—Å–µ—Ö –≤ –ª–æ–±–±–∏:
          setInLobby(true);
          setGameState(null);
          break;

        default:
          console.warn('–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø —Å–æ–æ–±—â–µ–Ω–∏—è:', msg.type);
      }
    };
    return () => ws.close();
  }, []);

  // –∏–≥—Ä–æ–≤—ã–µ –∫–æ–º–∞–Ω–¥—ã
  const handleOpen = (x, y) => {
    socket.send(JSON.stringify({
      type: 'game/open',
      payload: { x, y, player: myId }
    }));
  };

  const handleFlag = (x, y) => {
    socket.send(JSON.stringify({
      type: 'game/flag',
      payload: { x, y, player: myId }
    }));
  };

  // –ø—Ä–∏ —Ä–µ—Å—Ç–∞—Ä—Ç–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º UI –≤ –ª–æ–±–±–∏
  const handleRestart = () => {
    socket.send(JSON.stringify({ type: 'game/restart' }));
    // –µ—Å–ª–∏ –≤—ã —Ö—Ä–∞–Ω–∏–ª–∏ gameState –≤ localStorage, —Ç–æ–∂–µ —Å–±—Ä–æ—Å—å—Ç–µ –µ–≥–æ:
    localStorage.removeItem('sapper-state');
  };

  // —Ä–∞–Ω–∂–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ –æ—á–∫–∞–º: [ [id, score], ... ], —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ —É–±—ã–≤–∞–Ω–∏—é –æ—á–∫–æ–≤
  const ranking = gameState
    ? Object.entries(gameState.scores)
      .sort(([idA, scoreA], [idB, scoreB]) => {
        const explodedA = gameState.exploded === idA;
        const explodedB = gameState.exploded === idB;
        // —Å–Ω–∞—á–∞–ª–∞ –Ω–µ‚Äë–≤–∑–æ—Ä–≤–∞–≤—à–∏–µ—Å—è (false) –≤—ã—à–µ, –≤–∑–æ—Ä–≤–∞–≤—à–∏–µ—Å—è (true) –Ω–∏–∂–µ
        if (explodedA !== explodedB) {
          return explodedA ? 1 : -1;
        }
        // –µ—Å–ª–∏ –æ–±–∞ –≤ –æ–¥–Ω–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ ‚Äî —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ —É–±—ã–≤–∞–Ω–∏—é –æ—á–∫–æ–≤
        return scoreB - scoreA;
      })
    : [];

  if (inLobby) {
    return (
      <Lobby
        socket={socket}
        myId={myId}
        players={lobbyPlayers}
      />
    );
  }

  if (!gameState) {
    return <div>–ó–∞–≥—Ä—É–∑–∫–∞ –∏–≥—Ä—ã‚Ä¶</div>;
  }

  return (
    <div className="app">
      <h1>–°–∞–ø—ë—Ä: –ö–æ—Ä–æ–ª–µ–≤—Å–∫–∞—è –±–∏—Ç–≤–∞</h1>
      <Timer timeLeft={gameState['time-left']} />
      <ScoreBoard players={lobbyPlayers} scores={gameState.scores} />
      <GameBoard board={gameState.board}
        onOpen={handleOpen}
        onFlag={handleFlag} />
      {gameState.status === "ended" && (
        <div className="overlay">
          <h2>–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!</h2>
          <table className="results-table">
            <thead>
              <tr><th>‚Ññ</th><th>–ò–≥—Ä–æ–∫</th><th>–†–µ–∑—É–ª—å—Ç–∞—Ç</th></tr>
            </thead>
            <tbody>
              {ranking.map(([id, score], idx) => {
                const nick = lobbyPlayers[id]?.nick || id;
                const cell = (gameState.exploded === id)
                  ? 'üí•'
                  : score;
                return (
                  <tr key={id} className={id === myId ? 'highlight' : ''} >
                    <td>{idx + 1}</td>
                    <td>{nick}</td>
                    <td>{cell}</td>
                  </tr>
                );
              })}
            </tbody>
          </table>
          <button onClick={handleRestart} className="restart-button">
            –ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ
          </button>
        </div>
      )}
    </div>
  );
};

export default App;

import React from 'react';

const Cell = ({ x, y, cell, onOpen, onFlag }) => {
  const handleClick = () => onOpen(x, y);
  const handleRightClick = (e) => {
    e.preventDefault();
    onFlag(x, y);
  };

  let className = 'cell';
  let content = '';

  if (cell.opened) {
    className += ' open';
    if (cell.mine) content = 'üí•';
    else if (cell.adjacent > 0) content = cell.adjacent;
  } else if (cell.flagged) {
    content = 'üö©';
  }

  return (
    <div
      className={className}
      onClick={handleClick}
      onContextMenu={handleRightClick}
    >
      {content}
    </div>
  );
};

export default Cell;

(ns sapper.core
  (:require
    [org.httpkit.server :as http]
    [compojure.core :refer [GET POST routes]]
    [compojure.route :as route]
    [ring.middleware.defaults :refer [wrap-defaults site-defaults]]
    [sapper.ws :refer [ws-handler]]
    [sapper.state :refer [init-game-state]])
  (:gen-class))

(defn app []
  (routes
    (GET "/ws" [] ws-handler) ; WebSocket endpoint
    (route/resources "/")      ; –æ—Ç–¥–∞—á–∞ —Å—Ç–∞—Ç–∏–∫–∏ (build –∫–ª–∏–µ–Ω—Ç–∞)
    (route/not-found "404 Not Found")))

(defn -main [& args]
  (println "Starting Sapper Game Server on port 8080...")
  (init-game-state) ; –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã
  (http/run-server (wrap-defaults (app) site-defaults) {:port 8080}))


(ns sapper.game
  (:require [clojure.set :as set]))

;; –ü–æ–¥—Å—á—ë—Ç –º–∏–Ω –≤–æ–∫—Ä—É–≥ –∫–ª–µ—Ç–∫–∏
(defn count-adjacent-mines [board x y]
  (let [rows (count board)
        cols (count (first board))
        neighbors (for [dx [-1 0 1]
                        dy [-1 0 1]
                        :let [nx (+ x dx) ny (+ y dy)]
                        :when (and (not (and (= dx 0) (= dy 0))) ; –∏—Å–∫–ª—é—á–∞–µ–º —Å–∞–º—É –∫–ª–µ—Ç–∫—É
                                   (>= nx 0) (< nx rows)
                                   (>= ny 0) (< ny cols))]
                    (get-in board [nx ny]))]
    (count (filter :mine neighbors))))

;; –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è
(defn generate-board
  [rows cols n-mines]
  (let [total-cells (* rows cols)
        mine-positions (set (take n-mines (shuffle (range total-cells))))
        mine? #(contains? mine-positions %)
        to-pos (fn [x y] (+ (* x cols) y))]

    (let [initial-board
          (vec (for [x (range rows)]
                 (vec (for [y (range cols)]
                        {:x x
                         :y y
                         :mine (mine? (to-pos x y))
                         :adjacent 0
                         :opened false
                         :flagged false
                         :flagged-by nil}))))

          updated-board
          (vec (for [x (range rows)]
                 (vec (for [y (range cols)]
                        (let [adj (count-adjacent-mines initial-board x y)]
                          (assoc (get-in initial-board [x y]) :adjacent adj))))))]
      updated-board)))




;; –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è –∏–≥—Ä—ã
(defn game-complete? [state]
  (let [board (:board state)
        all-cells (apply concat board)
        unopened (filter #(not (:opened %)) all-cells)
        all-mines (every? :mine unopened)]
    all-mines))

;; –ü–æ–¥—Å—á—ë—Ç –æ—á–∫–æ–≤ –∏–≥—Ä–æ–∫–∞
(defn update-score [state x y player]
  (let [cell (get-in (:board state) [x y])]
    (if (and (:flagged cell) (:mine cell))
      (update-in state [:scores player] inc)
      state)))

;; –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–±–µ–¥–∏—Ç–µ–ª—è –ø–æ –æ—á–∫–∞–º
(defn calculate-winner [state]
  (let [scores (:scores state)]
    ;; –µ—Å–ª–∏ –µ—Å—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω –∏–≥—Ä–æ–∫ ‚Äì –±–µ—Ä—ë–º entry [id score] —Å –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–º score
    (when (seq scores)
      (key (apply max-key val scores)))))

;; –û—Ç–∫—Ä—ã—Ç–∏–µ –∫–ª–µ—Ç–∫–∏
(defn open-cell [state x y player]
  (let [board (:board state)
        cell  (get-in board [x y])]
    (if (or (:opened cell) (:flagged cell))
      state
      (let [adj           (count-adjacent-mines board x y)
            opened-board  (assoc-in board [x y :opened] true)
            updated-board (assoc-in opened-board [x y :adjacent] adj)
            new-state     (assoc state :board updated-board)]
        (cond
           ;; –í–∑—Ä—ã–≤: –æ—Ç–º–µ—á–∞–µ–º, –∫—Ç–æ –ø–æ–¥–æ—Ä–≤–∞–ª—Å—è, —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –µ–º—É –æ—á–∫–∏ –∏ –∑–∞–≤–µ—Ä—à–∞–µ–º
            (:mine cell)
              (-> new-state
                  (assoc :status   :ended
                         :winner   (calculate-winner new-state)
                         :exploded player)
                  (assoc :scores  (assoc (:scores new-state) player 0)))

          ;; –µ—Å–ª–∏ –æ—Ç–∫—Ä—ã–ª–∏ –≤—Å—ë ‚Äì –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ
          (game-complete? new-state)
            (assoc new-state
                   :status :ended
                   :winner (calculate-winner new-state))

          :else
            new-state)))))

;; –£—Å—Ç–∞–Ω–æ–≤–∫–∞/—Å–Ω—è—Ç–∏–µ —Ñ–ª–∞–≥–∞
(defn toggle-flag [state x y player]
  (let [board (:board state)
        cell  (get-in board [x y])
        opened? (:opened cell)
        owner   (:flagged-by cell)]
    (cond
      ;; –ù–µ–ª—å–∑—è —Å—Ç–∞–≤–∏—Ç—å/—Å–Ω–∏–º–∞—Ç—å —Ñ–ª–∞–≥ –Ω–∞ —É–∂–µ –æ—Ç–∫—Ä—ã—Ç–æ–π –∫–ª–µ—Ç–∫–µ
      opened?
      state

      ;; –ï—Å–ª–∏ —Ñ–ª–∞–≥ –Ω–µ —Å—Ç–æ–∏—Ç ‚Äî —Å—Ç–∞–≤–∏–º –µ–≥–æ –æ—Ç –∏–º–µ–Ω–∏ player
      (nil? owner)
      (let [updated-cell  (-> cell
                              (assoc  :flagged true
                                      :flagged-by player))
            updated-board (assoc-in board [x y] updated-cell)
            new-state     (assoc state :board updated-board)]
        (update-score new-state x y player))

      ;; –ï—Å–ª–∏ —Ñ–ª–∞–≥ —Å—Ç–æ–∏—Ç –∏ –µ–≥–æ –∞–≤—Ç–æ—Ä ‚Äî —Ç–æ—Ç –∂–µ –∏–≥—Ä–æ–∫ ‚Äî —Å–Ω–∏–º–∞–µ–º
      (= owner player)
      (let [updated-cell  (-> cell
                              (assoc :flagged false
                                     :flagged-by nil))
            updated-board (assoc-in board [x y] updated-cell)]
        (assoc state :board updated-board))

      ;; –ï—Å–ª–∏ —Ñ–ª–∞–≥ —Å—Ç–æ–∏—Ç, –Ω–æ –∞–≤—Ç–æ—Ä –¥—Ä—É–≥–æ–π ‚Äî –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º
      :else
      state)))

(defn new-game
  "rows cols mines, –∏ —Å–ø–∏—Å–æ–∫ player-IDs"
  ([rows cols mines players]
   {:board     (generate-board rows cols mines)
    :revealed  #{}
    :flags     #{}
    :scores    (into {} (map (fn [pid] [pid 0]) players))
    :status    :playing
    :time-left 120
    :players   players})
  ;; –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏, –µ—Å–ª–∏ –∫—Ç–æ-—Ç–æ –≤—ã–∑—ã–≤–∞–µ—Ç new-game –±–µ–∑ —Å–ø–∏—Å–∫–∞
  ([rows cols mines]
   (new-game rows cols mines [1 2])))



import React from 'react';
import ReactDOM from 'react-dom/client';
import './styles.css';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);



import React, { useState } from 'react';

const Lobby = ({ socket, myId, players }) => {
  const [nick, setNick] = useState('');

  const count = Object.keys(players).length;

  const changeNick = () => {
    socket.send(JSON.stringify({
      type: 'lobby/set-nick',
      payload: nick
    }));
  };

  const toggleReady = () => {
    socket.send(JSON.stringify({
      type: 'lobby/toggle-ready'
    }));
  };

  return (
    <div className="lobby">
      <h1>–ò–≥—Ä–æ–≤–æ–µ –ª–æ–±–±–∏</h1>
      <div className="nick-input">
        <input
          className="nick-input-field"
          value={nick}
          onChange={e => setNick(e.target.value)}
          placeholder="–í–≤–µ–¥–∏—Ç–µ –Ω–∏–∫"
        />
        <button className="nick-input-button" onClick={changeNick}>OK</button>
      </div>
      <h2 className="lobby-count">–ò–≥—Ä–æ–∫–æ–≤: {count}</h2>
      <ul className="lobby-list">
        {Object.entries(players).map(([id, p]) => (
          <li key={id} className={id === myId ? 'self' : ''}>
            {p.nick}{' '}
            {p.ready ? <span role="img" aria-label="–ì–æ—Ç–æ–≤">‚úÖ</span> : <span role="img" aria-label="–ù–µ –≥–æ—Ç–æ–≤">‚ùå</span>}
          </li>
        ))}
      </ul>
      <button className="ready-button" onClick={toggleReady}>
        –ì–æ—Ç–æ–≤ / –ù–µ –≥–æ—Ç–æ–≤
      </button>
    </div>
  );
};

export default Lobby;


(defproject sapper "0.1.0-SNAPSHOT"
  :description "Multiplayer Sapper Game on Clojure Server"
  :dependencies [[org.clojure/clojure "1.11.1"]
                 [http-kit "2.7.0"]
                 [compojure "1.7.0"]
                 [cheshire "5.11.0"]
                 [org.clojure/core.async "1.6.681"]
                 [ring/ring-defaults "0.3.4"]]   ; ‚Üê –≠–¢–û –í–ê–ñ–ù–û
  :main sapper.core
  :target-path "target/%s"
  :resource-paths ["resources"]
  :profiles {:uberjar {:aot :all
                       :uberjar-name "sapper.jar"}})



(ns sapper.state
  (:require
  [clojure.core.async :refer [chan go-loop <! timeout alt! close!]]
   [cheshire.core :as json]
   [org.httpkit.server :as http]
   [sapper.game :as game]))


;; –û–±—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
(def game-state (ref {}))

;; –°–ø–∏—Å–æ–∫ –∫–ª–∏–µ–Ω—Ç–æ–≤ (WebSocket —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π)
(def clients (atom #{}))

;; –ö–∞–Ω–∞–ª –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–±—ã—Ç–∏–π –æ—Ç –∏–≥—Ä–æ–∫–æ–≤
(def event-chan (chan))

;; –∫–∞–Ω–∞–ª‚Äë—Å–∏–≥–Ω–∞–ª –¥–ª—è –ª–æ–±–±–∏: channel -> player-id
(def client-ids (atom {}))

;; —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ª–æ–±–±–∏: player-id -> {:nick string :ready boolean}
(defonce lobby-state (atom {}))

; –∫–∞–Ω–∞–ª‚Äë—Å–∏–≥–Ω–∞–ª –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ —Ç–∞–π–º–µ—Ä–∞
(defonce exit-ch (atom nil))

;; –¥–ª—è –Ω—É–º–µ—Ä–∞—Ü–∏–∏ –Ω–æ–≤—ã—Ö –∏–≥—Ä–æ–∫–æ–≤
(defonce join-counter (atom 0))

;; –æ—Ç—Å–∞–Ω–æ–≤–∫–∞ —Ç–∞–π–º–µ—Ä–∞
(defn stop-timer! []
  (when-let [ch @exit-ch]
    (close! ch)))

;; –¥–æ–±–∞–≤–ª—è–µ—Ç –Ω–æ–≤–æ–≥–æ –∏–≥—Ä–æ–∫–∞ –≤ –ª–æ–±–±–∏
(defn add-player! [player-id]
  (swap! lobby-state assoc player-id {:nick player-id :ready false}))

;; —É–¥–∞–ª—è–µ—Ç –∏–≥—Ä–æ–∫–∞ –∏–∑ –ª–æ–±–±–∏
(defn remove-player! [player-id]
  (swap! lobby-state dissoc player-id))

;; —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –Ω–∏–∫ –∏–≥—Ä–æ–∫–∞
(defn set-player-nick! [player-id nick]
  (swap! lobby-state assoc-in [player-id :nick] nick))

;; –ø–µ—Ä–µ–∫–ª—é—á–∞–µ—Ç –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å
(defn toggle-player-ready! [player-id]
  (swap! lobby-state update-in [player-id :ready] not))

;; —Ä–∞–∑–¥–∞—Ç—å –≤—Å–µ–º –∫–ª–∏–µ–Ω—Ç–∞–º —Ç–µ–∫—É—â–µ–µ –ª–æ–±–±–∏
(defn broadcast-lobby! []
  (let [msg (json/generate-string {:type    "lobby/update"
                                   :players @lobby-state})]
    (doseq [ch @clients]
      (http/send! ch msg))))

(defn broadcast-state! []
  (let [msg       {:type  "state"
                   :state @game-state}
        json-msg (json/generate-string msg)]
    (doseq [client @clients]
      (http/send! client json-msg))))

;; –ó–∞–ø—É—Å–∫ —Ü–∏–∫–ª–∞ —Ç–∞–π–º–µ—Ä–∞, –∫–æ—Ç–æ—Ä—ã–π –∫–∞–∂–¥—É—é —Å–µ–∫—É–Ω–¥—É —É–º–µ–Ω—å—à–∞–µ—Ç time-left
(defn start-timer! []
  (let [ch (chan)]
    (reset! exit-ch ch)
    (go-loop []
      (alt!
        ch ([_])
        (timeout 1000) ([_]
          (dosync
            (when (pos? (:time-left @game-state))
              (alter game-state update :time-left dec)))
          (broadcast-state!)
          (if (pos? (:time-left @game-state))
            (recur)
            (do
              (dosync
                (alter game-state
                       assoc
                       :status :ended
                       :winner (game/calculate-winner @game-state)))
              (broadcast-state!))))))))

(defn init-game-state []
  (let [pids (keys @lobby-state)]
    (dosync
      (ref-set game-state
        (game/new-game 20 20 40 pids)))
    (broadcast-state!)
    (start-timer!)))

(defn handle-game-event [event]
  (let [{t :type{:keys [x y player]} :payload} event]
    (dosync
      (case t
        "game/open"
          (alter game-state game/open-cell x y player)
        "game/flag"
          (alter game-state game/toggle-flag x y player)
        "game/restart"
          (do
            (stop-timer!)
            (init-game-state))
        nil)))
  ;; –µ—Å–ª–∏ –∏–≥—Ä–∞ –∑–∞–∫–æ–Ω—á–∏–ª–∞—Å—å ‚Äî –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–∞–π–º–µ—Ä
  (when (= (:status @game-state) :ended)
    (stop-timer!))
  (broadcast-state!))

;; –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–æ–±—ã—Ç–∏–π –∏–∑ event-chan
(go-loop []
  (when-let [event (<! event-chan)]
    (handle-game-event event)
    (recur)))

(defn try-start-game! []
  (let [ps (vals @lobby-state)
        ready-count (count (filter :ready ps))]
    (when (and (not (:started? @game-state)) ; –µ—Å–ª–∏ –µ—â—ë –Ω–µ –∏–≥—Ä–∞–µ–º
               (>= (count ps) 2)
               (= ready-count (count ps)))
      ;; –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã –∏ —Ä–∞—Å–∫–∞—Ç—ã–≤–∞–µ–º —ç—Ç–æ –≤—Å–µ–º
      (stop-timer!)
      (init-game-state)
      (let [msg (json/generate-string {:type "game/start"})]
        (doseq [ch @clients]
          (http/send! ch msg))))))



(ns sapper.ws
  (:require
   [org.httpkit.server :as http]
   [cheshire.core :as json]
   [clojure.core.async :refer [put!]]
   [sapper.state :refer [clients client-ids
                         add-player! remove-player!
                         set-player-nick! toggle-player-ready!
                         broadcast-lobby! broadcast-state! try-start-game!
                         event-chan lobby-state broadcast-lobby! join-counter]]))

(defn ws-handler [req]
  (http/with-channel req channel
    ;; 1) –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π player-id –∏ –ø–æ—Ä—è–¥–∫–æ–≤—ã–π –Ω–æ–º–µ—Ä –¥–ª—è –Ω–∏–∫–∞
    (let [player-id    (str (hash channel))
          num          (swap! join-counter inc)
          default-nick (str "–∏–≥—Ä–æ–∫-" num)]
      ;; 2) —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞–Ω–∞–ª –∏ id
      (swap! clients conj channel)
      (swap! client-ids assoc channel player-id)

      ;; 3) –¥–æ–±–∞–≤–ª—è–µ–º –≤ –ª–æ–±–±–∏ –∏ —Å—Ä–∞–∑—É –¥–∞—ë–º –¥—Ä—É–∂–µ–ª—é–±–Ω—ã–π –Ω–∏–∫
      (add-player! player-id)
      (set-player-nick! player-id default-nick)

      ;; 4) —à–ª—ë–º —Ç–æ–ª—å–∫–æ —á—Ç–æ –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–≤—à–µ–º—É—Å—è –µ–≥–æ id
      (http/send! channel
        (json/generate-string {:type "lobby/joined" :id player-id}))

      ;; 5) –æ–±–Ω–æ–≤–ª—è–µ–º —É –≤—Å–µ—Ö —Å–ø–∏—Å–æ–∫ –ª–æ–±–±–∏ –∏ (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ) —Ç–µ–∫—É—â–µ–µ –∏–≥—Ä–æ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
      (broadcast-lobby!)
      (broadcast-state!)

      ;; 6) –ø—Ä–∏ –¥–∏—Å–∫–æ–Ω–Ω–µ–∫—Ç–µ —É–¥–∞–ª—è–µ–º –∏–≥—Ä–æ–∫–∞
      (http/on-close channel
        (fn [_]
          (let [pid (@client-ids channel)]
            (remove-player! pid)
            (swap! clients disj channel)
            (swap! client-ids dissoc channel)
            (broadcast-lobby!))))

      ;; 7) –Ω–∞ –≤—Å–µ –≤—Ö–æ–¥—è—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è
      (http/on-receive channel
        (fn [raw]
          (let [{type    :type
                 payload :payload} (json/parse-string raw true)
                pid (@client-ids channel)]
            (case type
              ;; –ª–æ–±–±–∏‚Äë—Å–æ–±—ã—Ç–∏—è
              "lobby/set-nick"
                (do (set-player-nick! pid payload)
                  (broadcast-lobby!))
              "lobby/toggle-ready"
                (do (toggle-player-ready! pid)
                  (broadcast-lobby!)
                  (when (try-start-game!)))
              ;; –∏–≥—Ä–æ–≤—ã–µ —Å–æ–±—ã—Ç–∏—è
              "game/open"
                (put! event-chan {:type type :payload payload})
              "game/flag"
                (put! event-chan {:type type :payload payload})
              "game/restart"
                (do
                  ;; —Å–±—Ä–æ—Å –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç–æ–≤
                  (swap! lobby-state
                    (fn [l]
                      (into {}
                        (map (fn [[k v]]
                              [k (assoc v :ready false)])
                          l))))
                  (broadcast-lobby!)
                  (doseq [ch @clients]
                    (http/send! ch
                      (json/generate-string {:type "lobby/reset"}))))
              (println "Unknown message type:" type))))))))









